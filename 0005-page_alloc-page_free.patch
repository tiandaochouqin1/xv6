From bda99e080067bf7b2f8647f00c639c6f7a823c6f Mon Sep 17 00:00:00 2001
From: 6-1 <xv6@xv6.com>
Date: Mon, 13 Sep 2021 00:18:43 +0800
Subject: [PATCH 5/5] page_alloc & page_free

---
 kern/pmap.c | 60 ++++++++++++++++++++++++++++++++++-------------------
 1 file changed, 39 insertions(+), 21 deletions(-)

diff --git a/kern/pmap.c b/kern/pmap.c
index bbb8609..d83709e 100644
--- a/kern/pmap.c
+++ b/kern/pmap.c
@@ -86,40 +86,31 @@ boot_alloc(uint32_t n)
 {
 	static char *nextfree;	// virtual address of next byte of free memory
 	char *result;
-    int pagenum = 0;
     struct PageInfo * tpage;
 	// Initialize nextfree if this is the first time.
 	// 'end' is a magic symbol automatically generated by the linker,
 	// which points to the end of the kernel's bss segment:
 	// the first virtual address that the linker did *not* assign
 	// to any kernel code or global variables.
-	if (!nextfree) {
+	if(!nextfree) {
 		extern char end[];
 		nextfree = ROUNDUP((char *) end, PGSIZE);
 	}
+    cprintf("nextfree=%p\n",nextfree);
 
 	// Allocate a chunk large enough to hold 'n' bytes, then update
 	// nextfree.  Make sure nextfree is kept aligned
 	// to a multiple of PGSIZE.
 	//
 	// LAB 2: Your code here.
-    pagenum = n/PGSIZE + 1; 
-    if((int) (pagenum*PGSIZE + nextfree) >= 0xeebfd000){
-        panic("out of mem\n");
-    }
+    if((uint32_t)ROUNDUP(nextfree+n, PGSIZE) - KERNBASE >(npages * PGSIZE))
+        panic("out of memory!\n");
 
-    for(int loop = 0; loop < pagenum; loop++){
-       tpage = page_alloc(ALLOC_ZERO); 
-       tpage->pp_ref ++;
-    }
-    if(n == 0){
-        result = (char*) tpage->pp_link;
-    }
-    else{
-        result = nextfree;
-        nextfree += pagenum * PGSIZE;
-    }
 
+    result = nextfree;
+    nextfree = ROUNDUP(nextfree+n, PGSIZE);
+
+    cprintf("boot_alloc ok\n");
 	return result;
 }
 
@@ -147,6 +138,7 @@ mem_init(void)
 	//////////////////////////////////////////////////////////////////////
 	// create initial page directory.
 	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);
+    
 	memset(kern_pgdir, 0, PGSIZE);
 
 	//////////////////////////////////////////////////////////////////////
@@ -166,6 +158,8 @@ mem_init(void)
 	// to initialize all fields of each struct PageInfo to 0.
 	// Your code goes here:
 
+    pages = (struct PageInfo*) boot_alloc(npages * sizeof(struct PageInfo));
+    memset(pages, 0, npages * sizeof(struct PageInfo));
 
 	//////////////////////////////////////////////////////////////////////
 	// Now that we've allocated the initial kernel data structures, we set
@@ -269,10 +263,18 @@ page_init(void)
 	// NB: DO NOT actually touch the physical memory corresponding to
 	// free pages!
 	size_t i;
+    size_t num_iohole = IOPHYSMEM/PGSIZE;
+    size_t num_allocated = ((int) boot_alloc(0)- KERNBASE)/PGSIZE;
 	for (i = 0; i < npages; i++) {
-		pages[i].pp_ref = 0;
-		pages[i].pp_link = page_free_list;
-		page_free_list = &pages[i];
+        if((i==0) | (i >= npages_basemem && i<npages_basemem + num_iohole + num_allocated)){
+            pages[i].pp_ref = 1;
+        }
+        else{
+            pages[i].pp_ref = 0;
+            pages[i].pp_link = page_free_list;
+            page_free_list = &pages[i];
+
+        }
 	}
 }
 
@@ -292,7 +294,18 @@ struct PageInfo *
 page_alloc(int alloc_flags)
 {
 	// Fill this function in
-	return 0;
+    struct PageInfo *result;
+    if(page_free_list == NULL)
+       return NULL;
+
+    result = page_free_list;
+    page_free_list = result->pp_link;
+    result->pp_link = NULL;
+
+    if(alloc_flags & ALLOC_ZERO)
+         memset(page2kva(result), 0, PGSIZE);
+
+	return result;
 }
 
 //
@@ -305,6 +318,11 @@ page_free(struct PageInfo *pp)
 	// Fill this function in
 	// Hint: You may want to panic if pp->pp_ref is nonzero or
 	// pp->pp_link is not NULL.
+    if(pp->pp_link || pp->pp_ref){
+        panic("pp_ref nonzero or pp_ref not null\n");
+    }
+    pp->pp_link = page_free_list;
+    page_free_list = pp;
 }
 
 //
-- 
2.17.1

